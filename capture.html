<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QuakeVision - Client-side Screenshot (Full UI)</title>

<!-- Tailwind -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
tailwind.config = { theme:{ extend:{ colors:{ broadcast:{ bg:'#20252e', panel:'rgba(0,0,0,0.85)' }}, fontFamily:{ sans:['"Helvetica Neue"', 'Arial', '"Hiragino Kaku Gothic ProN"', '"Hiragino Sans"', 'Meiryo', 'sans-serif'] } } } };
</script>

<!-- d3 / topojson -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>

<style>
html,body { height:100%; margin:0; background:#20252e; color:#fff; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif; }
#capture-root { width:100vw; height:100vh; position:relative; overflow:hidden; }

/* map container (inside capture-root) */
#map-container { position:absolute; inset:0; width:100%; height:100%; z-index:0; background:#20252e; }

/* UI panels (these are inside capture-root so will be captured) */
.info-panel, .bg-panel { backdrop-filter: blur(4px); }
.intensity-text { font-family: 'Arial', sans-serif; font-weight:900; text-anchor:middle; dominant-baseline:central; pointer-events:none; letter-spacing:-0.5px; }
.point-circle { transition: r 80ms linear, stroke-width 80ms linear; }
.hypocenter-mark { stroke:#ff0000; stroke-linecap:round; filter: drop-shadow(0 0 4px rgba(0,0,0,0.85)); transition: transform 80ms linear, stroke-width 80ms linear; }

/* basic status overlay */
#screenshot-status { position:fixed; left:50%; top:8px; transform:translateX(-50%); z-index:9999; background:rgba(0,0,0,0.6); color:white; padding:6px 10px; border-radius:6px; font-weight:700; font-size:13px; display:none; }

/* make capture preview not selectable */
.capture-preview { pointer-events:none; }
</style>
</head>
<body>

<!-- Everything inside #capture-root will be captured -->
<div id="capture-root">
  <div id="map-container"></div>

  <!-- UI: left top panels -->
  <div class="absolute top-6 left-6 z-10 flex flex-col gap-4 pointer-events-none">
    <div class="info-panel bg-black/80 text-white rounded shadow-2xl overflow-hidden min-w-[320px] max-w-md pointer-events-auto">
      <div class="flex h-24">
        <div class="bg-yellow-400 text-black w-28 flex flex-col justify-center items-center shrink-0">
          <span class="text-xs font-bold opacity-80 mb-[-4px]">æœ€å¤§éœ‡åº¦</span>
          <span id="info-max-scale" class="text-6xl font-black tracking-tighter leading-none mt-1">-</span>
        </div>
        <div class="flex-1 p-4 flex flex-col justify-center">
          <div id="info-time" class="text-xl font-bold mb-1 leading-tight">--æ—¥ --æ™‚--åˆ†ã”ã‚</div>
          <div class="text-sm text-gray-400">ç™ºç”Ÿ</div>
        </div>
      </div>
    </div>

    <div class="bg-black/80 text-white p-5 rounded-sm shadow-2xl min-w-[320px] pointer-events-auto border-l-4 border-gray-600">
      <div class="grid grid-cols-[auto_1fr] gap-x-6 gap-y-2 items-baseline">
        <div class="text-gray-400 text-xs font-bold">éœ‡æºåœ°</div>
        <div id="info-hypocenter" class="text-2xl font-bold text-yellow-50 leading-none">---</div>

        <div class="text-gray-400 text-xs font-bold">è¦æ¨¡</div>
        <div class="text-xl">M<span id="info-magnitude" class="font-bold text-2xl ml-1">---</span></div>

        <div class="text-gray-400 text-xs font-bold">æ·±ã•</div>
        <div class="text-xl"><span id="info-depth" class="font-bold text-2xl ml-1">---</span></div>
      </div>
    </div>

    <div id="info-tsunami-box" class="bg-blue-900/95 text-white px-5 py-3 rounded-sm shadow-2xl font-bold text-lg flex items-center gap-3 pointer-events-auto border-l-4 border-blue-500">
      <span class="text-2xl">ğŸŒŠ</span>
      <span id="info-tsunami">æƒ…å ±å–å¾—ä¸­...</span>
    </div>
  </div>

  <!-- UI: bottom-right -->
  <div class="absolute bottom-6 right-6 z-10 flex flex-col items-end gap-3 pointer-events-none">
    <button id="toggle-list-btn" class="pointer-events-auto bg-gray-800 hover:bg-gray-700 text-white px-5 py-2.5 rounded shadow-lg text-sm font-bold transition-all flex items-center gap-2 border border-gray-600">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
      å±¥æ­´ãƒªã‚¹ãƒˆ
    </button>
    <div class="text-[10px] text-gray-500 bg-black/40 px-2 py-1 rounded backdrop-blur-sm">
      Powered by P2PQuake API / JMA / TopoJSON
    </div>
  </div>

  <!-- right slide panel -->
  <div id="quake-list-panel" class="absolute top-0 right-0 h-full w-80 bg-gray-900/95 backdrop-blur-md shadow-2xl z-20 hidden transform translate-x-full transition-transform">
    <div class="p-4 bg-gray-800/80 border-b border-gray-700 flex justify-between items-center shrink-0">
      <h2 class="font-bold text-gray-100">åœ°éœ‡å±¥æ­´</h2>
      <button id="close-list-btn" class="text-gray-400 hover:text-white transition-colors">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
      </button>
    </div>
    <div id="quake-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
  </div>
</div>

<!-- status -->
<div id="screenshot-status">ç”Ÿæˆä¸­â€¦</div>

<!-- optional fallback lib (only used as fallback) -->
<script src="https://cdn.jsdelivr.net/npm/dom-to-image-more@2.9.0/dist/dom-to-image-more.min.js"></script>

<script>
/* ============================================================================
   --- åœ°å›³æç”»ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå…ˆã»ã©ã®ã‚³ãƒ¼ãƒ‰ã‚’ã»ã¼ãã®ã¾ã¾çµ±åˆï¼‰ ---
   æ³¨æ„: ä¸»è¦ãª ID ã¯ capture-root, map-container, info-* ç­‰ã§ã™ã€‚
   ============================================================================ */

const INTENSITY_COLORS = {
  "1":"#888","2":"#1f77b4","3":"#2ca02c","4":"#e6c200","5-":"#ff9900","5+":"#ff6600",
  "6-":"#d62728","6+":"#a50021","7":"#800080","default":"#555"
};
const BLACK_TEXT_SCALES = ["4","5-","5+"];

const API_HISTORY = 'https://api.p2pquake.net/v2/history?codes=551&limit=20';
const API_LOCATIONS = 'https://files.nakn.jp/earthquake/code/PointSeismicIntensityLocation.json';
const API_MAP = 'https://raw.githubusercontent.com/dataofjapan/land/master/japan.topojson';

const state = { quakes: [], locationMap: new Map(), mapData: null, selectedId: null };
let svg, gMap, overlayLayer, projection, pathGenerator, zoomBehavior;

document.addEventListener('DOMContentLoaded', async () => {
  setupUI();
  initMap();
  try {
    await loadAllData();
    if (state.mapData) renderBaseMap();
    if (state.quakes.length > 0) { selectQuake(state.quakes[0].id); renderHistoryList(); }
  } catch (err) {
    console.error(err); showMapError("ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
  }
  // After init, check URL params to auto-capture
  startAutoCaptureIfRequested();
});

/* UI toggles */
function setupUI(){
  const listPanel = document.getElementById('quake-list-panel');
  const toggleBtn = document.getElementById('toggle-list-btn');
  const closeBtn = document.getElementById('close-list-btn');
  const toggle = () => {
    const open = listPanel.classList.toggle('open');
    if (!open) { listPanel.classList.add('translate-x-full'); listPanel.classList.remove('translate-x-0'); }
    else { listPanel.classList.remove('translate-x-full'); listPanel.classList.add('translate-x-0'); }
  };
  toggleBtn.onclick = toggle; closeBtn.onclick = toggle;
}

function showMapError(msg){
  const el = document.getElementById('screenshot-status');
  el.style.display = 'block'; el.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + msg;
}
function hideMapError(){ const el = document.getElementById('screenshot-status'); el.style.display = 'none'; }

/* Data load */
async function loadAllData(){
  const [historyRes, locationRes, mapRes] = await Promise.all([
    fetch(API_HISTORY).then(r=>r.json()),
    fetch(API_LOCATIONS).then(r=>r.json()),
    fetch(API_MAP).then(r=>r.json())
  ]);
  state.mapData = mapRes;
  Object.values(locationRes).forEach(item => {
    if (item && item.name && Array.isArray(item.location)) {
      const [lat, lon] = item.location;
      state.locationMap.set(item.name, [lon, lat]);
    }
  });
  state.quakes = historyRes
    .filter(q => q.earthquake && q.earthquake.hypocenter && q.earthquake.hypocenter.latitude !== -200)
    .map(q => {
      const mappedPoints = (q.points || []).map(p => {
        const coords = state.locationMap.get(p.addr);
        return { ...p, coords: coords || null };
      }).filter(p => p.coords !== null);
      return {
        id: q.id,
        time: q.earthquake.time,
        hypocenter: q.earthquake.hypocenter,
        maxScale: q.earthquake.maxScale,
        domesticTsunami: q.earthquake.domesticTsunami,
        points: mappedPoints
      };
    });
}

/* Map init */
function initMap(){
  const container = document.getElementById('map-container');
  const { width, height } = container.getBoundingClientRect();
  svg = d3.select('#map-container').append('svg')
    .attr('width','100%').attr('height','100%')
    .attr('viewBox',[0,0,width,height])
    .style('background-color','#20252e');
  gMap = svg.append('g').attr('class','land-layer');
  overlayLayer = svg.append('g').attr('class','overlay-layer').attr('pointer-events','none').style('z-index',5);
  projection = d3.geoMercator().center([137,38]).scale(width*2.5).translate([width/2,height/2]);
  pathGenerator = d3.geoPath().projection(projection);
  zoomBehavior = d3.zoom()
    .scaleExtent([1,100])
    .on('zoom', (event) => {
      gMap.attr('transform', event.transform);
      repositionSymbols();
      updateIconSizes(event.transform.k);
    });
  svg.call(zoomBehavior);
  window.addEventListener('resize', () => {
    const w = container.clientWidth, h = container.clientHeight;
    svg.attr('viewBox',[0,0,w,h]);
    projection.translate([w/2,h/2]);
    renderBaseMap(); repositionSymbols();
  });
}

/* renderBaseMap */
function renderBaseMap(){
  if (!state.mapData) return;
  try {
    const container = document.getElementById('map-container');
    const width = container.clientWidth, height = container.clientHeight;
    let features = null;
    if (state.mapData.objects && typeof state.mapData.objects === 'object') {
      let objKey = null;
      if ('japan' in state.mapData.objects) objKey = 'japan';
      else { const keys = Object.keys(state.mapData.objects); if (keys.length>0) objKey = keys[0]; }
      if (!objKey) throw new Error('TopoJSON: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      try { features = topojson.feature(state.mapData, state.mapData.objects[objKey]); }
      catch(e){
        const all = [];
        Object.keys(state.mapData.objects).forEach(k => {
          try { const f = topojson.feature(state.mapData, state.mapData.objects[k]); if (f && f.features) all.push(...f.features); } catch(e){}
        });
        if (all.length>0) features = { type:'FeatureCollection', features: all }; else throw e;
      }
    } else if (state.mapData.type === 'FeatureCollection') features = state.mapData;
    if (!features || !features.features || features.features.length === 0) throw new Error('åœ°å›³ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚£ãƒ¼ãƒãƒ£ãŒç©º');
    projection.fitSize([width,height], features);
    pathGenerator = d3.geoPath().projection(projection);
    gMap.selectAll('path').data(features.features).join('path')
      .attr('d', pathGenerator).attr('fill','#374151').attr('stroke','#4b5563').attr('stroke-width',0.5);
    repositionSymbols();
  } catch(e) { console.error('renderBaseMap error', e); showMapError('åœ°å›³æç”»å¤±æ•—'); }
}

/* selectQuake & plotting (same as before) */
function selectQuake(id){
  state.selectedId = id;
  const quake = state.quakes.find(q=>q.id===id);
  if (!quake) return;
  updateInfoPanel(quake);
  updateMapPlots(quake);
  fitBounds(quake);
  const k = d3.zoomTransform(svg.node()).k || 1;
  updateIconSizes(k); repositionSymbols();
}
function updateInfoPanel(quake){
  const d = new Date(quake.time);
  const timeStr = `${d.getDate()}æ—¥ ${d.getHours()}æ™‚${String(d.getMinutes()).padStart(2,'0')}åˆ†ã”ã‚`;
  document.getElementById('info-max-scale').textContent = getScaleLabel(quake.maxScale);
  document.getElementById('info-time').textContent = timeStr;
  document.getElementById('info-hypocenter').textContent = quake.hypocenter.name || '---';
  document.getElementById('info-depth').textContent = quake.hypocenter.depth === 0 ? 'ã”ãæµ…ã„' : `${quake.hypocenter.depth}km`;
  document.getElementById('info-magnitude').textContent = quake.hypocenter.magnitude.toFixed(1);
  const tsunamiEl = document.getElementById('info-tsunami');
  const tsunamiBox = document.getElementById('info-tsunami-box');
  let tText="æ´¥æ³¢ã®å¿ƒé…ãªã—", isWarning=false;
  switch(quake.domesticTsunami){
    case "None": tText="æ´¥æ³¢ã®å¿ƒé…ãªã—"; break;
    case "Checking": tText="æ´¥æ³¢æœ‰ç„¡ã‚’èª¿æŸ»ä¸­"; break;
    case "NonEffective": tText="è‹¥å¹²ã®æµ·é¢å¤‰å‹•ã‚ã‚Š"; break;
    case "Watch": tText="æ´¥æ³¢æ³¨æ„å ±"; isWarning=true; break;
    case "Warning": tText="æ´¥æ³¢è­¦å ±"; isWarning=true; break;
    default: tText="æ´¥æ³¢æƒ…å ±ã«æ³¨æ„"; break;
  }
  tsunamiEl.textContent = tText;
  tsunamiBox.className = isWarning
    ? "bg-red-600 text-white px-5 py-3 rounded-sm shadow-2xl font-bold text-lg flex items-center gap-3 pointer-events-auto border-l-4 border-red-300"
    : "bg-blue-900/95 text-white px-5 py-3 rounded-sm shadow-2xl font-bold text-lg flex items-center gap-3 pointer-events-auto border-l-4 border-blue-500";
}
function updateMapPlots(quake){
  overlayLayer.selectAll('*').remove();
  const sortedPoints = [...quake.points].sort((a,b)=>a.scale - b.scale);
  const pointGroups = overlayLayer.selectAll('g.point').data(sortedPoints, d=>d.addr || Math.random()).join('g').attr('class','point').each(function(d){ this.__coords = d.coords; });
  pointGroups.each(function(d){
    const label = getScaleLabel(d.scale);
    let baseR = 5; if (["7","6+"].includes(label)) baseR=10; else if (["6-","5+"].includes(label)) baseR=8; else if (label==="4") baseR=6;
    d._baseRadius = baseR;
    let baseFont=10; if (["7","6+"].includes(label)) baseFont=14; else if (["6-","5+"].includes(label)) baseFont=11; else baseFont=8;
    d._baseFont = baseFont;
  });
  pointGroups.append('circle').attr('class','point-circle').attr('r',4).attr('fill', d => INTENSITY_COLORS[getScaleLabel(d.scale)] || '#999').attr('stroke','white').attr('stroke-width',1);
  pointGroups.append('text').attr('class','intensity-text').attr('font-size','10px').attr('fill', d => BLACK_TEXT_SCALES.includes(getScaleLabel(d.scale)) ? 'black' : 'white').text(d => getScaleLabel(d.scale));
  const hypo = quake.hypocenter;
  if (hypo && hypo.latitude !== -200 && isFinite(hypo.latitude) && isFinite(hypo.longitude)){
    const hg = overlayLayer.append('g').attr('class','hypo-group').each(function(){ this.__hypo = [hypo.longitude, hypo.latitude]; });
    hg.append('path').attr('class','hypocenter-mark').attr('d',"M-10,-10 L10,10 M-10,10 L10,-10").attr('fill','none').attr('stroke-width',4).attr('transform','scale(1)');
  }
  repositionSymbols();
  const k = d3.zoomTransform(svg.node()).k || 1; updateIconSizes(k);
}
function repositionSymbols(){
  if (!overlayLayer || !projection) return;
  const t = d3.zoomTransform(svg.node());
  overlayLayer.selectAll('g.point').each(function(){
    const node = this;
    const coords = node.__coords || (d3.select(this).datum() && d3.select(this).datum().coords) || null;
    if (!coords || !Array.isArray(coords)){ d3.select(this).style('display','none'); return; }
    try {
      const proj = projection(coords);
      if (!proj || !isFinite(proj[0]) || !isFinite(proj[1])) { d3.select(this).style('display','none'); return; }
      const screen = t.apply(proj);
      d3.select(this).attr('transform', `translate(${screen[0]},${screen[1]})`).style('display', null);
    } catch (e) { console.warn('repositionSymbols point error', e); d3.select(this).style('display','none'); }
  });
  overlayLayer.selectAll('g.hypo-group').each(function(){
    const node = this;
    const hypo = node.__hypo || null;
    if (!hypo || !Array.isArray(hypo)){ d3.select(this).style('display','none'); return; }
    try {
      const proj = projection(hypo);
      if (!proj || !isFinite(proj[0]) || !isFinite(proj[1])) { d3.select(this).style('display','none'); return; }
      const screen = t.apply(proj);
      d3.select(this).attr('transform', `translate(${screen[0]},${screen[1]})`).style('display', null);
    } catch (e) { console.warn('repositionSymbols hypo error', e); d3.select(this).style('display','none'); }
  });
}
function updateIconSizes(k){
  if (!overlayLayer) return;
  if (!k || !isFinite(k)) k = 1;
  const kk = Math.max(0.1, k);
  const zoomFactor = (k) => Math.min(3, 1 + Math.log10(k + 1) * 0.7);
  overlayLayer.selectAll('g.point').each(function(d){
    const group = d3.select(this);
    const datum = d || group.datum();
    const baseR = datum && datum._baseRadius ? datum._baseRadius : 5;
    const baseFont = datum && datum._baseFont ? datum._baseFont : 8;
    const zf = zoomFactor(kk);
    const desiredR = Math.max(3, Math.min(40, baseR * zf));
    const desiredFont = Math.max(8, Math.min(28, baseFont * zf));
    const desiredStrokePx = Math.max(0.6, Math.min(6, 1.2 * zf));
    group.selectAll('circle.point-circle').interrupt().transition().duration(80).attr('r', desiredR).attr('stroke-width', desiredStrokePx);
    group.selectAll('text.intensity-text').interrupt().transition().duration(80).attr('font-size', `${desiredFont}px`);
  });
  overlayLayer.selectAll('g.hypo-group').each(function(){
    const group = d3.select(this);
    const extra = zoomFactor(kk);
    const pathScale = extra;
    const desiredStrokePx = Math.max(0.8, Math.min(10, 3.5 * extra));
    group.selectAll('path.hypocenter-mark').interrupt().transition().duration(80).attr('transform', `scale(${pathScale})`).attr('stroke-width', desiredStrokePx).attr('opacity', 1);
  });
}
function fitBounds(quake){
  const points = [];
  if (quake.hypocenter.latitude !== -200) points.push([quake.hypocenter.longitude, quake.hypocenter.latitude]);
  quake.points.forEach(p => points.push(p.coords));
  if (points.length === 0) return;
  let minLon=180,maxLon=-180,minLat=90,maxLat=-90;
  points.forEach(([lon,lat]) => { if (lon<minLon) minLon=lon; if (lon>maxLon) maxLon=lon; if (lat<minLat) minLat=lat; if (lat>maxLat) maxLat=lat; });
  const pad = 0.5;
  const bounds = [ projection([minLon-pad, maxLat+pad*0.5]), projection([maxLon+pad, minLat-pad*0.5]) ];
  const svgEl = document.querySelector('svg');
  const width = svgEl.clientWidth, height = svgEl.clientHeight;
  const dx = bounds[1][0] - bounds[0][0], dy = bounds[1][1] - bounds[0][1];
  const x = (bounds[0][0]+bounds[1][0])/2, y = (bounds[0][1]+bounds[1][1])/2;
  const offsetX = width > 768 ? width * -0.1 : 0;
  const scale = Math.max(1, Math.min(30, 0.9 / Math.max(dx/width, dy/height)));
  const translate = [ width/2 - scale * x + offsetX, height/2 - scale * y ];
  svg.transition().duration(1000).ease(d3.easeCubicOut).call(zoomBehavior.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale))
    .end().then(()=>{ repositionSymbols(); const kk = d3.zoomTransform(svg.node()).k || 1; updateIconSizes(kk); }).catch(()=>{ repositionSymbols(); const kk = d3.zoomTransform(svg.node()).k || 1; updateIconSizes(kk); });
}
function getScaleLabel(scale){
  switch(scale){
    case 10: return "1"; case 20: return "2"; case 30: return "3";
    case 40: return "4"; case 45: case 46: return "5-";
    case 50: return "5+"; case 55: return "6-"; case 60: return "6+";
    case 70: return "7"; default: return "?";
  }
}
function renderHistoryList(){
  const container = document.getElementById('quake-list-container');
  container.innerHTML = '';
  state.quakes.forEach(q => {
    const div = document.createElement('div');
    const isSelected = q.id === state.selectedId;
    div.className = `p-3 rounded cursor-pointer border transition-all duration-200 flex items-center gap-3 ${isSelected ? 'bg-gray-700 border-yellow-500 shadow-md transform scale-[1.02]' : 'bg-gray-800 border-transparent hover:bg-gray-700 hover:border-gray-600'}`;
    const label = getScaleLabel(q.maxScale);
    const color = INTENSITY_COLORS[label];
    const textColor = BLACK_TEXT_SCALES.includes(label) ? 'text-black' : 'text-white';
    const timeStr = new Date(q.time).toLocaleString('ja-JP', {month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit'});
    div.innerHTML = `
      <div class="w-10 h-10 rounded-md flex items-center justify-center font-black text-lg shadow-sm shrink-0 ${textColor}" style="background:${color}">
        ${label}
      </div>
      <div class="flex-1 min-w-0">
        <div class="text-xs text-gray-400 font-mono mb-0.5">${timeStr}</div>
        <div class="text-sm font-bold text-gray-100 truncate">${q.hypocenter.name || 'éœ‡æºåœ°ä¸æ˜'}</div>
        <div class="flex gap-2 text-xs text-gray-400 mt-0.5">
          <span>M${q.hypocenter.magnitude.toFixed(1)}</span>
          <span>${q.hypocenter.depth}km</span>
        </div>
      </div>
    `;
    div.onclick = () => selectQuake(q.id);
    container.appendChild(div);
  });
}

/* ============================================================================
   --- ã“ã“ã‹ã‚‰ã€Œç”»é¢å…¨ä½“ã€ã‚’PNGã«ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ ---
   - ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯:
   * #capture-root ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ computed style ã‚’ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã«ã‚³ãƒ”ãƒ¼
   * SVG ã® foreignObject ã«å…¥ã‚Œã¦ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º -> data URL -> image -> canvas
   * canvas.toBlob -> ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ or preview
   * fallback: dom-to-image-more
   ============================================================================ */

/** copy computed styles from source -> target (deep) */
function inlineAllStyles(sourceEl, cloneEl) {
  const sEls = [sourceEl, ...sourceEl.querySelectorAll('*')];
  const tEls = [cloneEl, ...cloneEl.querySelectorAll('*')];
  for (let i = 0; i < sEls.length; i++) {
    const s = sEls[i], t = tEls[i];
    if (!t) continue;
    const cs = window.getComputedStyle(s);
    for (let j = 0; j < cs.length; j++) {
      const prop = cs[j];
      try { t.style.setProperty(prop, cs.getPropertyValue(prop), cs.getPropertyPriority(prop)); } catch(e){}
    }
    // copy class list? already present in cloneNode(true)
    // for svg elements copy width/height attributes if present
    if (s instanceof SVGElement && t instanceof SVGElement) {
      if (s.getAttribute('width')) t.setAttribute('width', s.getAttribute('width'));
      if (s.getAttribute('height')) t.setAttribute('height', s.getAttribute('height'));
    }
  }
}

/** build foreignObject SVG string from cloned node */
function buildForeignObjectSVG(clone, width, height) {
  // Ensure proper namespaces
  const svgNS = 'http://www.w3.org/2000/svg';
  const xhtmlNS = 'http://www.w3.org/1999/xhtml';
  const svgEl = document.createElementNS(svgNS, 'svg');
  svgEl.setAttribute('xmlns', svgNS);
  svgEl.setAttribute('width', width);
  svgEl.setAttribute('height', height);
  svgEl.setAttribute('viewBox', `0 0 ${width} ${height}`);
  const fo = document.createElementNS(svgNS, 'foreignObject');
  fo.setAttribute('width', '100%');
  fo.setAttribute('height', '100%');
  const wrapper = document.createElementNS(xhtmlNS, 'div');
  wrapper.setAttribute('xmlns', xhtmlNS);
  wrapper.style.width = width + 'px';
  wrapper.style.height = height + 'px';
  wrapper.appendChild(clone);
  fo.appendChild(wrapper);
  svgEl.appendChild(fo);
  const serialized = new XMLSerializer().serializeToString(svgEl);
  return serialized;
}

/** capture #capture-root as PNG
 * options: { width, height, scale, background, filename, fallbackDomToImage }
 */
async function captureCaptureRoot(options = {}) {
  const root = document.getElementById('capture-root');
  if (!root) throw new Error('#capture-root not found');
  const bbox = root.getBoundingClientRect();
  const width = options.width || Math.round(bbox.width) || 1200;
  const height = options.height || Math.round(bbox.height) || 630;
  const scale = options.scale || (window.devicePixelRatio || 1);

  // clone node and inline styles
  const clone = root.cloneNode(true);
  // remove status UI if present in clone for clean output
  const statusClone = clone.querySelector('#screenshot-status');
  if (statusClone) statusClone.remove();
  inlineAllStyles(root, clone);

  // Build SVG with foreignObject
  let svgString;
  try {
    svgString = buildForeignObjectSVG(clone, width, height);
  } catch (e) {
    console.warn('foreignObject SVG build failed, fallback to dom-to-image', e);
    if (options.fallbackDomToImage !== false && window.domtoimage) {
      return fallbackDomToImage(root, { width, height, scale, filename: options.filename });
    }
    throw e;
  }

  // Create image from svg data url
  const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = Math.round(width * scale);
        canvas.height = Math.round(height * scale);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = options.background || getComputedStyle(document.body).backgroundColor || '#20252e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(blob => {
          if (!blob) return reject(new Error('toBlob failed'));
          resolve(blob);
        }, 'image/png');
      } catch (err) { reject(err); }
    };
    img.onerror = (e) => {
      console.warn('Image load error for svgDataUrl', e);
      // fallback to dom-to-image if available
      if (window.domtoimage) {
        return fallbackDomToImage(root, { width, height, scale, filename: options.filename }).then(resolve).catch(reject);
      }
      reject(new Error('Image load error: ' + e));
    };
    img.src = svgDataUrl;
  });
}

/** fallback using dom-to-image-more (less crisp sometimes) */
async function fallbackDomToImage(node, { width, height, scale, filename } = {}) {
  if (!window.domtoimage) throw new Error('dom-to-image-more not available');
  // domtoimage takes node and options
  const style = { transform: 'scale(1)', 'transform-origin': 'top left' };
  const opts = { width, height, style, bgcolor: getComputedStyle(document.body).backgroundColor || '#20252e' };
  return domtoimage.toBlob(node, opts);
}

function downloadBlob(blob, filename='capture.png') {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 2000);
}

/* parse query params */
function getParams(){
  const p = new URLSearchParams(location.search);
  return {
    auto: p.get('auto') !== '0' && p.get('auto') !== 'false',
    quakeId: p.get('quakeId') || null,
    w: p.get('w') ? parseInt(p.get('w'),10) : null,
    h: p.get('h') ? parseInt(p.get('h'),10) : null,
    scale: p.get('scale') ? parseFloat(p.get('scale')) : 2,
    filename: p.get('filename') || `quake-map.png`,
    raw: p.get('raw') === '1' || p.get('raw') === 'true',
    wait: p.get('wait') ? parseInt(p.get('wait'),10) : 900
  };
}

/* wait for map data to be ready heuristics */
async function waitForDataReady(timeout = 8000) {
  try {
    await Promise.race([
      new Promise((_, reject) => setTimeout(()=>reject(new Error('timeout')), timeout)),
      (async () => {
        try {
          await new Promise((resolve, reject) => {
            const id = setInterval(()=> {
              const t = document.getElementById('info-time');
              if (t && !/--/.test(t.textContent)) { clearInterval(id); resolve(); }
            }, 200);
            setTimeout(()=> { clearInterval(id); reject(new Error('info-time wait timeout')); }, timeout);
          });
          return;
        } catch(e){}
        await new Promise((resolve2, reject2) => {
          const check = () => {
            const p = document.querySelector('.overlay-layer g.point, .overlay-layer g.hypo-group');
            if (p) return resolve2();
            setTimeout(check, 200);
          };
          setTimeout(()=> reject2(new Error('overlay wait timeout')), timeout);
          check();
        });
      })()
    ]);
  } catch(e) { console.warn('waitForDataReady:', e.message); }
}

/* Auto-capture orchestrator */
async function startAutoCaptureIfRequested(){
  const params = getParams();
  if (!params.auto) return;
  const status = document.getElementById('screenshot-status'); status.style.display = 'block'; status.textContent = 'åœ°å›³èª­ã¿è¾¼ã¿ã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™â€¦';
  await waitForDataReady(7000);
  if (params.quakeId) {
    try { if (typeof window.selectQuake === 'function') { window.selectQuake(params.quakeId); await new Promise(r=>setTimeout(r, Math.max(600, params.wait))); } }
    catch(e){ console.warn('selectQuake problem', e); }
  }
  status.textContent = 'ç”»åƒã‚’ç”Ÿæˆä¸­â€¦';
  try {
    const blob = await captureCaptureRoot({ width: params.w, height: params.h, scale: params.scale, filename: params.filename });
    status.textContent = 'ç”Ÿæˆå®Œäº† â€” ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­â€¦';
    if (params.raw) {
      // replace document with the image (API-like) and trigger download
      const url = URL.createObjectURL(blob);
      document.documentElement.innerHTML = '';
      const img = document.createElement('img'); img.src = url; img.style.width = '100%'; img.style.height = 'auto';
      document.body.style.margin = '0'; document.body.appendChild(img);
      downloadBlob(blob, params.filename);
    } else {
      downloadBlob(blob, params.filename);
      // add preview
      const prev = document.createElement('img'); prev.className = 'capture-preview';
      prev.src = URL.createObjectURL(blob);
      Object.assign(prev.style, { position:'fixed', right:'12px', bottom:'12px', width:'320px', boxShadow:'0 6px 20px rgba(0,0,0,.6)', border:'4px solid rgba(255,255,255,.06)', zIndex:9999 });
      document.body.appendChild(prev);
      setTimeout(()=> { try{ URL.revokeObjectURL(prev.src); } catch(e){} }, 6000);
    }
    status.textContent = 'å®Œäº†';
    setTimeout(()=> status.style.display = 'none', 1200);
  } catch (e) {
    console.error('capture error', e);
    // fallback attempt via dom-to-image-more
    try {
      const blob2 = await fallbackDomToImage(document.getElementById('capture-root'), { width: params.w || window.innerWidth, height: params.h || window.innerHeight, scale: params.scale });
      downloadBlob(blob2, params.filename);
      status.textContent = 'å®Œäº†ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰';
      setTimeout(()=> status.style.display = 'none', 1200);
    } catch (e2) {
      status.textContent = 'ç”»åƒä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (e.message || e2.message || e2);
      setTimeout(()=> status.style.display = 'none', 4000);
    }
  }
}

/* manual download helper (you can call from console) */
window.downloadCurrentView = async function(){
  try {
    const blob = await captureCaptureRoot({ width: window.innerWidth, height: window.innerHeight, scale: 2, filename: 'quake-capture.png' });
    downloadBlob(blob, 'quake-capture.png');
  } catch (e) {
    console.error('manual capture failed', e);
    alert('ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (e.message || e));
  }
};
</script>
</body>
</html>
